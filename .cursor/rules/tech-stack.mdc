---
description: Comprehensive guidelines for Next.js, TypeScript, Node.js, React, Shadcn UI, Prisma, PostgreSQL, and Manus agent with emphasis on simple, easy-to-use designs
alwaysApply: true
---

# Tech Stack Guidelines

You are an expert in TypeScript, Node.js, Next.js App Router, React, Shadcn UI, Prisma ORM, PostgreSQL, and Manus agent integration.

## Design Philosophy: Simplicity First

**CRITICAL**: Always prioritize simple, easy-to-use designs. Complexity should be justified by clear user benefit.

- **Keep UI components minimal and intuitive** - Users should understand functionality without documentation
- **Prefer straightforward data flows** - Avoid over-engineering with unnecessary abstractions
- **Use clear, descriptive naming** - Code should be self-documenting
- **Minimize configuration** - Defaults should work for 80% of use cases
- **Progressive enhancement** - Start simple, add complexity only when needed

## TypeScript & Node.js

### Type Safety

- Use strict TypeScript configuration (`strict: true`)
- Prefer `interface` over `type` for object shapes
- Avoid `any`; use `unknown` when type is truly unknown
- Use type guards for runtime validation

```typescript
// ✅ GOOD - Simple, type-safe
interface User {
  id: string;
  email: string;
  name: string;
}

function isValidUser(data: unknown): data is User {
  return (
    typeof data === "object" &&
    data !== null &&
    "id" in data &&
    "email" in data &&
    "name" in data
  );
}
```

### Code Organization

- Use functional programming patterns; avoid classes
- Keep functions focused and single-purpose
- Use descriptive variable names with auxiliary verbs (e.g., `isLoading`, `hasError`)
- Structure files: exports, subcomponents, helpers, types

## Next.js App Router

### Server Components First

- Default to Server Components; use `'use client'` only when necessary
- Use Server Actions for mutations instead of API routes when possible
- Leverage React Server Components for data fetching
- Use `React.cache()` for request-level deduplication

```typescript
// ✅ GOOD - Simple server component
import { cache } from "react";
import { prisma } from "@/prisma/prisma";

const getUser = cache(async (id: string) => {
  return await prisma.user.findUnique({ where: { id } });
});

export default async function UserPage({ params }: { params: { id: string } }) {
  const user = await getUser(params.id);
  return <div>{user.name}</div>;
}
```

### Performance

- Minimize `useEffect` and `useState`; prefer Server Components
- Use dynamic imports for non-critical components
- Wrap client components in Suspense with fallback
- Optimize images: WebP format, size data, lazy loading

### Routing

- Use `nuqs` for URL search parameter state management
- Keep route structure flat and intuitive
- Use route groups for organization without affecting URLs

## React Patterns

### Component Design

- Use functional components exclusively
- Keep components small and focused
- Extract custom hooks for reusable logic
- Prefer composition over prop drilling

```typescript
// ✅ GOOD - Simple, composable component
interface ButtonProps {
  children: React.ReactNode;
  onClick?: () => void;
  variant?: "primary" | "secondary";
}

export function Button({
  children,
  onClick,
  variant = "primary",
}: ButtonProps) {
  return (
    <button onClick={onClick} className={cn("btn", `btn-${variant}`)}>
      {children}
    </button>
  );
}
```

### State Management

- Use React Server Components for server state
- Use `useState` for local component state
- Use `useTransition` for non-urgent updates
- Avoid global state unless necessary

## Shadcn UI

### Component Usage

- Use Shadcn UI components as building blocks
- Customize via CSS variables and Tailwind classes
- Keep component variants minimal and purposeful
- Follow Shadcn's composition patterns

```typescript
// ✅ GOOD - Simple Shadcn usage
import { Button } from "@/components/ui/button";
import { Card, CardHeader, CardTitle, CardContent } from "@/components/ui/card";

export function UserCard({ user }: { user: User }) {
  return (
    <Card>
      <CardHeader>
        <CardTitle>{user.name}</CardTitle>
      </CardHeader>
      <CardContent>
        <Button variant="outline">View Profile</Button>
      </CardContent>
    </Card>
  );
}
```

### Styling

- Use Tailwind CSS utility classes
- Leverage CSS variables for theming
- Keep custom CSS minimal
- Use `cn()` utility for conditional classes

## Prisma ORM with PostgreSQL

### Prisma Client Setup

- Initialize Prisma Client as a singleton to prevent connection issues
- Use connection pooling for production environments
- Configure connection string via environment variables
- Enable query logging in development only

```typescript
// ✅ GOOD - Prisma Client singleton (prisma/prisma.ts)
import { PrismaClient } from "@prisma/client";

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined;
};

export const prisma =
  globalForPrisma.prisma ??
  new PrismaClient({
    log: process.env.NODE_ENV === "development" ? ["query", "error", "warn"] : ["error"],
  });

if (process.env.NODE_ENV !== "production") globalForPrisma.prisma = prisma;
```

### Schema Design

- Keep models simple and focused
- Use Prisma's built-in types for consistency
- Leverage relations for clear data relationships
- Use enums for constrained string values

```typescript
// ✅ GOOD - Simple Prisma schema
// prisma/schema.prisma

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@map("users")
}
```

### Query Patterns

- Use Prisma Client methods for type-safe queries
- Leverage `select` to fetch only needed fields
- Use `include` for related data when needed
- Prefer transactions for multi-step operations

```typescript
// ✅ GOOD - Simple Prisma queries
import { prisma } from "@/prisma/prisma";

export async function getUserById(id: string) {
  return await prisma.user.findUnique({
    where: { id },
    select: { id: true, email: true, name: true },
  });
}

// ✅ GOOD - Query with relations
export async function getUserWithPosts(id: string) {
  return await prisma.user.findUnique({
    where: { id },
    include: {
      posts: {
        orderBy: { createdAt: "desc" },
        take: 10,
      },
    },
  });
}

// ✅ GOOD - Complex query with filtering
export async function searchUsers(query: string) {
  return await prisma.user.findMany({
    where: {
      OR: [
        { name: { contains: query, mode: "insensitive" } },
        { email: { contains: query, mode: "insensitive" } },
      ],
    },
    take: 20,
  });
}

// ✅ GOOD - Transaction for consistency
export async function createUserWithProfile(
  userData: { email: string; name: string },
  profileData: { bio: string }
) {
  return await prisma.$transaction(async (tx) => {
    const user = await tx.user.create({
      data: userData,
    });

    const profile = await tx.profile.create({
      data: {
        ...profileData,
        userId: user.id,
      },
    });

    return { user, profile };
  });
}
```

### Migrations

- Use Prisma Migrate for schema changes
- Keep migrations focused and reversible
- Test migrations in development before production
- Name migrations descriptively with `--name`

```bash
# Create a new migration
npx prisma migrate dev --name add_user_profile

# Apply migrations in production
npx prisma migrate deploy

# Generate Prisma Client after schema changes
npx prisma generate
```

## PostgreSQL Best Practices with Prisma

### Connection Management

- Use Prisma's connection pooling automatically
- Configure connection limits in DATABASE_URL if needed
- Handle connection errors gracefully
- Close Prisma Client properly in serverless environments

```typescript
// ✅ GOOD - Connection pooling in DATABASE_URL
// DATABASE_URL="postgresql://user:password@host:5432/db?connection_limit=10&pool_timeout=20"
```

### Performance & Optimization

- Use transactions for data consistency
- Batch operations with `createMany`, `updateMany`, `deleteMany`
- Monitor query performance with Prisma's query logs
- Use indexes in your schema for frequently queried columns
- Leverage `select` to fetch only required fields

```typescript
// ✅ GOOD - Efficient batch operations
export async function createMultipleUsers(
  users: Array<{ email: string; name: string }>
) {
  return await prisma.user.createMany({
    data: users,
    skipDuplicates: true, // Skip duplicates instead of failing
  });
}

// ✅ GOOD - Select only needed fields
export async function getUserEmails() {
  return await prisma.user.findMany({
    select: { email: true }, // Only fetch email, not entire user
  });
}

// ✅ GOOD - Index in schema for performance
// prisma/schema.prisma
model User {
  id    String @id @default(cuid())
  email String @unique // Automatically indexed
  name  String
  
  @@index([name]) // Add index for name searches
  @@map("users")
}
```

## Manus Agent Integration

### Agent Usage

- Use Manus agent for AI-powered features
- Keep agent interactions simple and focused
- Handle errors gracefully with fallbacks
- Cache agent responses when appropriate

```typescript
// ✅ GOOD - Simple agent integration
import { ManusAgent } from "@manus/agent";

const agent = new ManusAgent({
  apiKey: process.env.MANUS_API_KEY,
});

export async function generateResponse(prompt: string) {
  try {
    const response = await agent.complete(prompt);
    return response.text;
  } catch (error) {
    console.error("Agent error:", error);
    return "Sorry, I encountered an error.";
  }
}
```

### Patterns

- Use server actions for agent calls
- Stream responses for better UX
- Validate inputs before agent calls
- Rate limit agent usage

```typescript
// ✅ GOOD - Server action with agent
"use server";

import { agent } from "@/lib/agent";

export async function chatAction(message: string) {
  if (!message.trim()) {
    return { error: "Message cannot be empty" };
  }

  const response = await agent.complete(message);
  return { text: response.text };
}
```

## Error Handling

### Simple Error Patterns

- Use try-catch for async operations
- Return error objects instead of throwing when appropriate
- Log errors with context
- Provide user-friendly error messages

```typescript
// ✅ GOOD - Simple error handling
export async function fetchUser(id: string) {
  try {
    const user = await prisma.user.findUnique({ where: { id } });
    if (!user) {
      return { error: "User not found" };
    }
    return { data: user };
  } catch (error) {
    console.error("Failed to fetch user:", error);
    return { error: "Failed to load user" };
  }
}
```

## Testing Considerations

- Write tests for critical paths
- Keep tests simple and focused
- Use TypeScript for type safety in tests
- Mock external dependencies appropriately

## File Structure

```
app/
  (routes)/
    page.tsx
components/
  ui/          # Shadcn components
  features/    # Feature-specific components
lib/
  utils.ts     # Utility functions
  agent.ts     # Manus agent setup
prisma/
  schema.prisma # Database schema
  prisma.ts    # Prisma Client singleton
  migrations/  # Database migrations
```

## Key Principles Summary

1. **Simplicity First** - Choose the simplest solution that works
2. **Type Safety** - Leverage TypeScript for correctness
3. **Server Components** - Default to RSC, use client components sparingly
4. **Clear Naming** - Code should be self-documenting
5. **Progressive Enhancement** - Start simple, add complexity only when needed
6. **Error Handling** - Handle errors gracefully with clear messages
7. **Performance** - Optimize for user experience, not premature optimization
8. **Maintainability** - Write code that's easy to understand and modify
